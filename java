加载、验证、准备、解析、初始化、使用、卸载七个阶段

加载时机
    new,loaderClass,forName,static访问或修改(赋值),static方法,反射创建类
加载 完全限定名查找类字节码文件,并且创建class对象在方法区
    双亲委派模型
    1.组合方式,先增加classloader的锁,防止多线程问题
    2.先判断是否加载过
    3.未加载过,递归调用父加载器指针加载loadClass
    4.如果加载失败,则使用本加载器加载

拓展
    启动类加载器 拓展类加载器 应用类加载器
    JDK\jre\lib JDK\jre\lib\ext ClassPath
    -Xbootclasspath java.ext.dirs系统变量
    全盘负责(该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入)
    父类委托 防止内存中出现多份同样的字节码
    缓存机制 为什么修改了Class后，必须重启JVM，程序的修改才会生效。
    双亲委派好处
    · 避免同一个类被多次加载；
    · 每个加载器只能加载自己范围内的类
    打破线程类加载器方法 重写loadClass(
    1. 自定义类加载器，重写loadClass方法;
    2. 使用线程上下文类加载器;
验证
    信息是否符合虚拟机要求
    文件格式验证,元数据验证,字节码验证,符号引用验证
准备
    为static变量分配内存并赋值默认值(final 是在编译时分配的),
定位方式访问
句柄
    堆中开辟句柄池,存放句柄地址.句柄地址中包含对象实例数据(堆)和类型数据(方法区)的地址信息
    引用存储的是句柄地址,如果有改动不用改动引用的句柄地址,只需要改动句柄地址的实例数据指针
直接引用
    速度快,节省访问指针定位的开销,直接指向存放实例数据的堆内存,堆内存中存放方法去类型数据元信息


回收