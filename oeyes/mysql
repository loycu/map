: MySQL中,可用如下方法: SELECT * FROM 表名称 LIMIT M,N 全表扫描 且顺序不稳定

建立主键或唯一索引, 利用索引(假设每页10条)
 SELECT * FROM 表名称 WHERE id_pk > (pageNum*10) LIMIT M
 实验表明，limit 20,1000 没有 limit 20 offset 1000效率来的高

 覆盖索引扫描；当扫描的索引列包含所有查询中需要的使用的列时，MySQL就可以直接使用索引返回需要的数据。

 总是取出全部的列：每次看到SELECT *的时候都需要怀疑是不是真的需要返回全部的列？取出全部列，会主优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的IO、内存和CPU的消耗。

 扫描的行数和返回的行数

 分析查询时，查看该查询扫描的行数是非常有帮助的。一定程度上能够说明该查询找到需要的数据的效率高不高。理想的情况下扫描的行数和返回的行数应该是相同的。当然这只是理想情况。一般来说扫描的行数对返回的行数的比率通常很小，一般在1：1到10：1之间。

 innodb_buffer_pool_size 缓存数据与索引
 innodb_log_file_size redolog 大小

 幸运的是从MySQL 5.5之后，崩溃恢复的性能的到了很大提升，这样你就可以同时拥有较高的写入性能和崩溃恢复性能了。
 max_connections 连接数

 log_bin

 如果你想让数据库服务器充当主节点的备份节点，那么开启二进制日志是必须的。