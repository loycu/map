redis高可用
我们知道，在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务（99.9%、99.99%、99.999% 等等）。
但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。
redis持久化
持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。
复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。
集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案

save命令和bgsave命令都可以生成RDB文件。
    save命令会阻塞Redis服务器进程
    bgsave命令会创建一个子进程,父进程(即Redis主进程)则继续处理请求。
        save m n
appendonly yes
aof AOF持久化：将执行的写命令备份到硬盘（类似于MySQL的binlog）

gossip 协议
单机无法保证高可用，需要引入多实例来提供高可用性
单机能够提供高达 8W 左右的QPS，再高的QPS则需要引入多实例
单机能够支持的数据量有限，处理更多的数据需要引入多实例；
单机所处理的网络流量已经超过服务器的网卡的上限值，需要引入多实例来分流。
有集群，集群往往需要维护一定的元数据，比如实例的ip地址，缓存分片的 slots 信息等，所以需要一套分布式机制来维护元数据的一致性。这类机制一般有两个模式：分散式和集中式
分散式机制将元数据存储在部分或者所有节点上，不同节点之间进行不断的通信来维护元数据的变更和一致性。Redis Cluster，Consul 等都是该模式
而集中式是将集群元数据集中存储在外部节点或者中间件上，比如 zookeeper。旧版本的 kafka 和 storm 等都是使用该模式。
https://redisson.org/glossary/redis-cluster.html