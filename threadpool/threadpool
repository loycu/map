降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

Executors 返回线程池对象的弊端如下：

FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。
CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。

为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。
 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容
 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。，
 说说 sleep() 方法和 wait() 方法区别和共同点? sleep() 方法没有释放锁，而 wait() 方法释放了锁 。

snowflake
 单表大于500w的时候就要分表

 唯一的 高并发的id

 数据库表 并发低 for update 修改效率低

 redis 并发一般 incre

 uuid 不重复 查询效率低

 雪花算法 分布式 效率高 唯一

 回拨 等待机器时间修正 抛异常切换 redis生成 打印Log 机器id+时间戳+序列号 SnowFlake每秒能够产生26万ID 一毫秒内可以生成4096个ID


 core PoolSize max workQueue threadFactory rejectHandler

 线程执行workQueue,如果不合适则拒绝策略调用
 core max factory都是用来初始化的
 如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。
 如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。

 SynchronousQueue多线程同步队列 newCachedThreadPool
 优先级 无限阻塞队列
 LinkedBlockingQueue 链表的无限阻塞队列
 ArrayBlockingQueue 数组有界阻塞队列

 AbortPolicy

 CallerRunsPolicy  直接当前线程运行

 DiscardOleddestPolicy 丢弃老任务,尝试执行这个任务
 DiscardPolicy丢弃

 当线程池中有任务需要执行时，线程池会判断如果线程数量没有超过核心数量就会新建线程池进行任务执行，
 如果线程池中的线程数量已经超过核心线程数，
 这时候任务就会被放入任务队列中排队等待执行；
 如果任务队列超过最大队列数，并且线程池没有达到最大线程数，
 就会新建线程来执行任务；如果超过了最大线程数，就会执行拒绝执行策略。

 面试题7:线程池为什么需要使用（阻塞）队列？

 主要有三点：

 因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换。
 面试题8:线程池为什么要使用阻塞队列而不使用非阻塞队列？

 阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。
 RUNNING：线程池的初始化状态，可以添加待执行的任务。
 SHUTDOWN：线程池处于待关闭状态，不接收新任务仅处理已经接收的任务。
 STOP：线程池立即关闭，不接收新的任务，放弃缓存队列中的任务并且中断正在处理的任务。
 TIDYING：线程池自主整理状态，调用 terminated() 方法进行线程池整理。
 TERMINATED：线程池终止状态。

 newScheduledThreadPool

 创建一个数量固定的线程池，支持执行定时性或周期性任务。

 newWorkStealingPool

 Java 8 新增创建线程池的方法，创建时如果不设置任何参数，则以当前机器CPU 处理器数作为线程个数，此线程池会并行处理任务，不能保证执行顺序。

 shutdown()：不会立即终止线程池，而是要等所有任务队列中的任务都执行完后才会终止。执行完 shutdown 方法之后，线程池就不会再接受新任务了。
 shutdownNow()：执行该方法，线程池的状态立刻变成 STOP 状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，执行此方法会返回未执行的任务

 .调用了shutdownNow或者shutdown，线程一定会退出么？

 这个是不一定的，因为线程池会调用线程的interrupt()来打断线程的执行，但是这个方法不会打断正在运行的线程，只对正在阻塞等待的线程生效，一旦线程执行的任务类似于一个死循环，那么任务永远不会执行完，那么线程永远都不会退出。

 为什么线程池要使用阻塞队列？

 因为线程一旦任务执行完之后，如果想让线程不退出，只能阻塞或者自旋来保证线程不会退出，阻塞会让cpu资源，但是自旋不会，所以为了防止线程退出和减少cpu的消耗，选择使用阻塞队列来保证线程不会退出。