有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）
ZooKeeper 提供了什么？

文件系统
通知机制
防脑裂 脑裂集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的leader节点，导致原有的集群出现多个leader节点的情况，这就是脑裂。
容错率 需要保证集群能够有半数进行投票

Kafka使用ZooKeeper管理自己的元数据配置。

监听Znode节点的数据变化
监听子节点的增减变化

如果是，则拿到锁。
释放锁：执行完操作后，把创建的节点给删掉
如果不是，则监听比自己要小1的节点变化

系统A拿到/locks节点下的所有子节点，经过比较，发现自己(id_000000)，是所有子节点最小的。所以得到锁
系统B拿到/locks节点下的所有子节点，经过比较，发现自己(id_000002)，不是所有子节点最小的。所以监听比自己小1的节点id_000001的状态
系统C拿到/locks节点下的所有子节点，经过比较，发现自己(id_000001)，不是所有子节点最小的。所以监听比自己小1的节点id_000000的状态
…...
等到系统A执行完操作以后，将自己创建的节点删除(id_000000)。通过监听，系统C发现id_000000节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁
….系统B如上

只要系统A挂了，那/groupMember/A这个节点就会删除，通过监听groupMember下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理)

除了能够感知节点的上下线变化，ZooKeeper还可以实现动态选举Master的功能。(如果集群是主从架构模式下)

原理也很简单，如果想要实现动态选举Master的功能，Znode节点的类型是带顺序号的临时节点(EPHEMERAL_SEQUENTIAL)就好了。

Zookeeper会每次选举最小编号的作为Master，如果Master挂了，自然对应的Znode节点就会删除。然后让新的最小编号作为Master，这样就可以实现动态选举的功能了
Paxos Zab FastPaxos

节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。
Paxos 算法就是一种基于消息传递模型的一致性算法。
。Paxos 算法适用的几种情况：一台机器中多个进程/线程达成数据一致；
分布式文件系统或者分布式数据库中多客户端并发读写数据；
分布式存储中多个副本响应读写请求的一致性。

每个 zookeeper 都会发出投票，由于是第一次选举 leader
，因此每个节点都 会把自己当做 leader 角色进行选举，

每个 zookeeper 的投票中都会包含自己 的 myid 和 zxid，此时 zookeeper 1 的投票为 myid 为 1，
初始 zxid 有一个初始 值，后期会随着数据更新而自动变化，zookeeper2 的投票为 myid 为 2，初始 zxid 为初始生成的值。
成为 Leader 的必要条件： Leader 要具有最高的 zxid；当集群的规模是 n 时，
集 群中大多数的机器（至少 n/2+1）得到响应并 follow 选出的 Leader。
心跳机制：Leader 与 Follower 利用 PING 来感知对方的是否存活，
当 Leader 无法 响应 PING 时，将重新发起 Leader 选举。
集群管理：监控节点存活状态、运行请求等；

主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 Zookeeper可以协助完成这个过程；
 Zookeeper Atomic Broadcast
 支持崩溃恢复 的 原子广播协议
 。Zab借鉴了Paxos算法
 就是指只有一台客户端（Leader）负责处理外部的写事务请求，然后Leader客户端将数据同步到其他Follower节点。
 Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交。
 Zab 协议的特性：
 1）Zab 协议需要确保那些已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交。
 2）Zab 协议需要确保丢弃那些只在 Leader 上被提出而没有被提交的事务。

 1）所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做 Leader服务器。其他剩余的服务器则是 Follower服务器。

 2）Leader服务器 负责将一个客户端事务请求，转换成一个 事务Proposal，并将该 Proposal 分发给集群中所有的 Follower 服务器，也就是向所有 Follower 节点发送数据广播请求（或数据复制）

 3）分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），在Zab协议中，只要超过半数的Follower服务器进行了正确的反馈后（也就是收到半数以上的Follower的Ack请求），那么 Leader 就会再次向所有的 Follower服务器发送 Commit 消息，要求其将上一个 事务proposal 进行提交。

leader选举

